'use strict';
var _state = "state", _node = "node", _match = "x";
function js() {
  for (var b = arguments, a = arguments[0][0], c = 1; c < arguments.length; c++) {
    a = a + b[c] + b[0][c];
  }
  return a.trim();
}
var copy = function(b) {
  var a = {}, c;
  for (c in b) {
    a[c] = b[c];
  }
  return a;
}, assignIndex = function(b) {
  return " var y" + (b + ("=" + (_state + (".y,x" + (b + ("=" + (_state + ".x;")))))));
}, restoreIndex = function(b) {
  return _state + (".y=y" + (b + (";" + (_state + (".x=x" + (b + ";"))))));
}, astExpression = function(b, a, c) {
  a = !!c.capture && !b.capture;
  var d = c.length && c.abort && _node + (".length=ln" + (c.length + ";")) || "";
  return " if((" + (_match + " = " + b.expression.id + "(" + _state + ")) " + (a ? "!=" : "==") + " null)" + ((a ? "{" + (_node + (".push(" + (_match + ");}else "))) : "") + ("{" + (restoreIndex(c.index) + (d + (c.abort + "}"))))));
}, astGroup = function(b, a, c) {
  var d = !!c.capture && !b.capture;
  c = copy(c);
  c.capture = d;
  return !c.length && d ? (c.length = a, "var ln" + (a + ("=" + (_node + ".length;"))) + (astSequence(b.sequence, a + 1, c) + "")) : astSequence(b.sequence, a + 1, c);
}, astChild = function(b, a, c) {
  return b.expression ? astExpression(b, a, c) : astGroup(b, a, c);
}, astQuantifier = function(b, a, c) {
  var d = c.index, f = c.abort, l = "inv_" + a, e = "loop_" + a;
  c = copy(c);
  "!" === b.capture && (c.index = a, c.abort = "break " + (l + ""));
  "+" === b.quantifier ? (e = copy(b), e.quantifier = "*", c = astChild(b, a, c) + (astQuantifier(e, a, c) + "")) : "*" === b.quantifier ? (c.length = 0, c.index = a, c.abort = "break " + (e + ";"), c = e + (":for(;;){" + (assignIndex(a) + (astChild(b, a, c) + "}")))) : "?" === b.quantifier ? (c.index = a, c.abort = "", c = assignIndex(a) + (astChild(b, a, c) + "")) : c = astChild(b, a, c);
  return "!" === b.capture ? l + (":{" + (assignIndex(a) + (c + (restoreIndex(d) + (f + "}"))))) : "=" === b.capture ? assignIndex(a) + (c + (restoreIndex(a) + "")) : c;
}, astSequence = function(b, a, c) {
  for (var d = b.alternation ? "alt_" + a : "", f = ""; b; b = b.alternation) {
    var l = "block_" + a, e = c;
    b.alternation && (e = copy(c), e.index = a, e.abort = "break " + (l + ";"));
    for (var h = "", k = 0; k < b.length; k++) {
      h += astQuantifier(b[k], a, e);
    }
    f = b.alternation ? f + (l + (":{" + (assignIndex(a) + (h + (" break " + (d + ";}")))))) : f + h;
  }
  return d ? d + (":{" + (f + "}")) : f;
}, astRoot = function(b, a, c) {
  return "(function(" + (_state + ("){" + (assignIndex(1) + (" var " + (_node + ("=[];var " + (_match + (";" + (astSequence(b, 2, {index:1, length:0, abort:"return;", capture:!0}) + (_node + (".tag=" + (a + (";return " + ((c ? "(" + (c + (")(" + (_node + ")"))) : _node) + ";})"))))))))))))));
}, syntaxError = function(b) {
  throw new SyntaxError('Unexpected token "' + b + '"');
}, parse = function(b, a) {
  for (var c = [], d = [], f = null, l, e = d, h, k, m = 0; m < b.length + a.length; m++) {
    0 !== m % 2 && (k = a[m++ >> 1], e.push({expression:k, capture:h}), h = void 0);
    var n = b[m >> 1];
    for (k = 0; k < n.length;) {
      var g = n[k++];
      " " !== g && "\t" !== g && "\r" !== g && "\n" !== g && ("|" === g && e.length ? e = e.alternation = [] : ")" === g && e.length ? (f = null, (e = c.pop()) || syntaxError(g)) : "(" === g ? (c.push(e), e.push(f = {sequence:[], capture:h}), e = f.sequence, h = void 0) : ":" === g || "=" === g || "!" === g ? (h = g, n[k] && "(" !== n[k] && syntaxError(g)) : "?" === g && !e.length && f ? (h = n[k++], ":" === h || "=" === h || "!" === h ? (f.capture = h, h = void 0) : syntaxError(g)) : "?" !== g && 
      "+" !== g && "*" !== g || !(l = e[e.length - 1]) ? syntaxError(g) : l.quantifier = g);
    }
  }
  return d;
}, isStickySupported = "boolean" === typeof/./g.sticky, execLambda = function(b) {
  return b.length ? b : function(a) {
    return b()(a);
  };
}, execString = function(b) {
  return function(a) {
    if (a.x < a.quasis.length) {
      for (var c = a.quasis[a.x], d = 0, f = b.length; d < f; d++) {
        if (c.charCodeAt(a.y + d) !== b.charCodeAt(d)) {
          return null;
        }
      }
      a.y += b.length;
      return b;
    }
  };
}, execRegex = function(b) {
  b = isStickySupported ? new RegExp(b.source, "y") : new RegExp(b.source + "|()", "g");
  return function(a) {
    if (a.x < a.quasis.length) {
      var c = a.quasis[a.x];
      b.lastIndex = a.y;
      var d;
      isStickySupported ? b.test(c) && (d = c.slice(a.y, b.lastIndex)) : (c = b.exec(c), null == c[1] && (d = c[0]));
      a.y = b.lastIndex;
      return d;
    }
  };
}, __pattern = function(b) {
  return "function" === typeof b ? execLambda(b) : "string" === typeof b ? execString(b) : execRegex(b);
}, interpolation = function(b) {
  return function(a) {
    if (a.x < a.expressions.length && a.y >= a.quasis[a.x].length) {
      a.y = 0;
      var c = a.expressions[a.x++];
      b && c && (c = b(c));
    }
    return c;
  };
}, parse$1 = function(b) {
  return function(a) {
    for (var c = [], d = arguments.length - 1; 0 < d--;) {
      c[d] = arguments[d + 1];
    }
    "string" === typeof a && (a = [a]);
    return b({quasis:a, expressions:c, x:0, y:0});
  };
};
function _ref(b, a) {
  return {id:"_" + a};
}
function _ref2(b, a) {
  return "_" + a;
}
var match = function(b, a) {
  return function(c) {
    for (var d = [], f = arguments.length - 1; 0 < f--;) {
      d[f] = arguments[f + 1];
    }
    f = parse(c, d.map(_ref));
    return (new Function("_n,_t," + d.map(_ref2).join(","), "return " + astRoot(f, "_n", a ? "_t" : null))).apply(void 0, [b, a].concat(d.map(__pattern)));
  };
};
exports.__pattern = __pattern;
exports.interpolation = interpolation;
exports.match = match;
exports.parse = parse$1

//# sourceMappingURL=reghex-core.js.map
